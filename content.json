{"meta":{"title":"葬瞳飘血的博客","subtitle":null,"description":"记录学习过程中遇到的问题","author":"葬瞳飘血","url":"https://jianlin1993.github.io","root":"/"},"pages":[{"title":"about","date":"2019-05-08T02:56:08.000Z","updated":"2019-05-13T02:33:46.613Z","comments":true,"path":"about/index.html","permalink":"https://jianlin1993.github.io/about/index.html","excerpt":"","text":"本博客记录个人学习过程的问题与知识点总结。所有文章系本人原创，转载请注明出处。 友情链接：葬瞳飘血-博客园"},{"title":"category","date":"2019-05-09T07:07:05.000Z","updated":"2019-05-09T07:07:05.543Z","comments":true,"path":"category/index.html","permalink":"https://jianlin1993.github.io/category/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-08T02:56:00.000Z","updated":"2019-05-08T02:56:00.814Z","comments":true,"path":"tags/index.html","permalink":"https://jianlin1993.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣-数据库-627-交换工资","slug":"力扣-数据库-627-交换工资","date":"2019-05-10T03:51:58.000Z","updated":"2019-05-10T06:09:52.804Z","comments":true,"path":"2019/05/10/力扣-数据库-627-交换工资/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-627-交换工资/","excerpt":"","text":"给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。 注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。 例如： id name sex salary 1 A m 2500 2 B f 1500 3 C m 5500 4 D f 500 运行你所编写的更新语句之后，将会得到以下表: id name sex salary 1 A f 2500 2 B m 1500 3 C f 5500 4 D m 500 1234--方法一：使用decodeupdate salary set sex=decode(sex,'f','m','f');--方法二：使用case whenupdate salary set sex=case sex when 'm' then 'f' else 'm' end;","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-626-换座位","slug":"力扣-数据库-626-换座位","date":"2019-05-10T03:51:46.000Z","updated":"2019-05-10T05:07:16.425Z","comments":true,"path":"2019/05/10/力扣-数据库-626-换座位/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-626-换座位/","excerpt":"","text":"小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。 其中纵列的 id 是连续递增的 小美想改变相邻俩学生的座位。 你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ 示例： |---------|---------| id student 1 Abbot 2 Doris 3 Emerson 4 Green 5 Jeames --------- --------- 假如数据输入的是上表，则输出结果如下： |---------|---------| id student 1 Doris 2 Abbot 3 Green 4 Emerson 5 Jeames --------- --------- 注意： 如果学生人数是奇数，则不需要改变最后一个同学的座位。 123456789101112131415方法一：SELECT (CASE WHEN MOD(id,2) = 1 AND id = (SELECT COUNT(*) FROM seat) THEN id WHEN MOD(id,2) = 1 THEN id|1 ElSE id-1 END) AS id, studentFROM seatORDER BY id;方法二：select id,case when mod(id,2)=1 and next_student is not null then next_student when mod(id,2)=0 then last_studentelse student end student from(select id,lag(student,1,null)over(order by id) last_student,student,lead(student,1,null)over(order by id) next_studentfrom seat )","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-620-有趣的电影","slug":"力扣-数据库-620-有趣的电影","date":"2019-05-10T03:51:35.000Z","updated":"2019-05-10T05:07:16.412Z","comments":true,"path":"2019/05/10/力扣-数据库-620-有趣的电影/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-620-有趣的电影/","excerpt":"","text":"某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。 作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。 例如，下表 cinema: |---------|-----------|--------------|-----------| id movie description rating 1 War great 3D 8.9 2 Science fiction 8.5 3 irish boring 6.2 4 Ice song Fantacy 8.6 5 House card Interesting 9.1 --------- ----------- -------------- ----------- 对于上面的例子，则正确的输出是为： |---------|-----------|--------------|-----------| id movie description rating 5 House card Interesting 9.1 1 War great 3D 8.9 --------- ----------- -------------- ----------- 12select id,movie,description,rating from cinemawhere mod(id,2)=1 and description!='boring' order by rating desc","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-601-体育馆的人流量","slug":"力扣-数据库-601-体育馆的人流量","date":"2019-05-10T03:51:14.000Z","updated":"2019-05-13T06:49:58.013Z","comments":true,"path":"2019/05/10/力扣-数据库-601-体育馆的人流量/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-601-体育馆的人流量/","excerpt":"","text":"X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。 请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。 例如，表 stadium： |------|------------|-----------| id date people 1 2017-01-01 10 2 2017-01-02 109 3 2017-01-03 150 4 2017-01-04 99 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 ------ ------------ ----------- 对于上面的示例数据，输出为： |------|------------|-----------| id date people 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 ------ ------------ ----------- Note: 每天只有一行记录，日期随着 id 的增加而增加。 12345678910111213141516171819202122232425262728--方法一：SELECT A.id, to_char(A.visit_date, 'yyyy-MM-dd') AS visit_date, A.peopleFROM stadium AWHERE A.people &gt;= 100 AND ((A.id - 1 IN ( SELECT id FROM stadium WHERE people &gt;= 100 ) AND A.id - 2 IN ( SELECT id FROM stadium WHERE people &gt;= 100 )) OR (A.id - 1 IN ( SELECT id FROM stadium WHERE people &gt;= 100 ) AND A.id | 1 IN ( SELECT id FROM stadium WHERE people &gt;= 100 )) OR (A.id | 1 IN ( SELECT id FROM stadium WHERE people &gt;= 100 ) AND A.id | 2 IN ( SELECT id FROM stadium WHERE people &gt;= 100 )) )ORDER BY A.id--方法二：使用分析函数WITH tmp AS ( SELECT id,last_id,next_id FROM ( select people,LAG(id,1,null)over(order by id) last_id,id,LEAD(id,1,null)over(order by id) next_id from stadium WHERE people &gt;=100 ) A WHERE (A.id=A.last_id | 1 AND A.id=A.next_id - 1))SELECT id,SUBSTR(visit_date,1,10) visit_date,people FROM stadium WHERE id =any(SELECT id FROM tmpUNION SELECT last_id FROM tmpUNION SELECT next_id FROM tmp)ORDER BY id","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-596-超过5名学生的课","slug":"力扣-数据库-596-超过5名学生的课","date":"2019-05-10T03:50:53.000Z","updated":"2019-05-10T05:07:16.374Z","comments":true,"path":"2019/05/10/力扣-数据库-596-超过5名学生的课/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-596-超过5名学生的课/","excerpt":"","text":"有一个courses 表 ，有: student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 例如,表: |---------|------------| student class A Math B English C Math D Biology E Math F Computer G Math H Math I Math --------- ------------ 应该输出: |---------| class Math --------- Note: 学生在每个课中不应被重复计算。 123456方法一：select class from (select distinct student,class from courses) group by class having count(*)&gt;=5方法二：select class from courses group by class having count(distinct student)&gt;=5;","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-595-大的国家","slug":"力扣-数据库-595-大的国家","date":"2019-05-10T03:50:29.000Z","updated":"2019-05-10T05:07:16.333Z","comments":true,"path":"2019/05/10/力扣-数据库-595-大的国家/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-595-大的国家/","excerpt":"","text":"这里有张 World 表 |-----------------|------------|------------|--------------|---------------| name continent area population gdp Afghanistan Asia 652230 25500100 20343000 Albania Europe 28748 2831741 12960000 Algeria Africa 2381741 37100000 188681000 Andorra Europe 468 78115 3712000 Angola Africa 1246700 20609294 100990000 ----------------- ------------ ------------ -------------- --------------- 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。 编写一个SQL查询，输出表中所有大国家的名称、人口和面积。 例如，根据上表，我们应该输出: |--------------|-------------|--------------| name population area Afghanistan 25500100 652230 Algeria 37100000 2381741 -------------- ------------- -------------- 123456789--方法一：使用orselect name,population,area from World where area &gt;3000000 or population &gt;25000000--方法二：使用union代替or 效率更高select name,population,area from World where area &gt;3000000 unionselect name,population,area from World where population &gt;25000000","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-262-行程和用户","slug":"力扣-数据库-262-行程和用户","date":"2019-05-10T03:50:11.000Z","updated":"2019-05-10T07:50:01.810Z","comments":true,"path":"2019/05/10/力扣-数据库-262-行程和用户/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-262-行程和用户/","excerpt":"","text":"Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。 Id Client_Id Driver_Id City_Id Status Request_at 1 1 10 1 completed 2013-10-01 2 2 11 1 cancelled_by_driver 2013-10-01 3 3 12 6 completed 2013-10-01 4 4 13 6 cancelled_by_client 2013-10-01 5 1 10 1 completed 2013-10-02 6 2 11 6 completed 2013-10-02 7 3 12 6 completed 2013-10-02 8 2 12 12 completed 2013-10-03 9 3 10 12 completed 2013-10-03 10 4 13 12 cancelled_by_driver 2013-10-03 Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。 Users_Id Banned Role 1 No client 2 Yes client 3 No client 4 No client 10 No driver 11 No driver 12 No driver 13 No driver 写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。 |------------|-------------------| Day Cancellation Rate 2013-10-01 0.33 2013-10-02 0.00 2013-10-03 0.50 123456789101112131415161718192021-- 非禁止用户取消率=非禁止用户行程取消总数(包括司机取消的)/非禁止用户行程总数方法一：select Request_at day,round(nvl(sum(case when Status = 'completed' then 0 else 1 end),0)/count(1),2) \"Cancellation Rate\" from(select A.status, A.request_at from Trips Ajoin users B on A.client_id = B.users_idwhere B.banned = 'No' and A.request_at between '2013-10-01' and '2013-10-03') group by Request_at--方法二：select B.day,round(nvl(A.num,0)/B.num,2) \"Cancellation Rate\" from (select nvl(count(*),0) num,Request_at Day from Trips A join users B on A.Client_Id=B.Users_Id--join users C on A.Client_Id=C.Users_Idwhere B.Banned='No' and A.Status=any('cancelled_by_driver','cancelled_by_client') and A.Request_at between '2013-10-01' and '2013-10-03'group by Request_at) Aright join --使用外连接 防止丢失数据(select nvl(count(*),1) num,Request_at Day from Trips A join users B on A.Client_Id=B.Users_Id--join users C on A.Client_Id=C.Users_Idwhere B.Banned='No' and A.Request_at between '2013-10-01' and '2013-10-03'group by Request_at) B on A.Day=B.Day order by B.day","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-197-上升的温度","slug":"力扣-数据库-197-上升的温度","date":"2019-05-10T03:15:58.000Z","updated":"2019-05-13T06:46:55.432Z","comments":true,"path":"2019/05/10/力扣-数据库-197-上升的温度/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-197-上升的温度/","excerpt":"","text":"给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。 |---------|------------------|------------------| Id(INT) RecordDate(DATE) Temperature(INT) 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 --------- ------------------ ------------------ 例如，根据上述给定的 Weather 表格，返回如下 Id: |----| Id 2 4 ---- 1234567891011--方法一：直接使用表自身连接select A.Idfrom Weather A join Weather Bon A.RecordDate = B.RecordDatewhere A.Temperature &gt; B.Temperature --方法二：使用偏移分析函数 根据日期（Date类型）排序（id和日期可能不是对应的）select id from (select id,Temperature,lag(Temperature,1,null)over(order by RecordDate) last_Temperature, RecordDate,lag(RecordDate,1,null)over(order by RecordDate) last_RecordDatefrom Weather) A where A.Temperature&gt;A.last_Temperature and A.last_RecordDate=A.RecordDate","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-185-部门工资前三高的员工","slug":"力扣-数据库-185-部门工资前三高的员工","date":"2019-05-10T03:01:38.000Z","updated":"2019-05-10T05:07:16.438Z","comments":true,"path":"2019/05/10/力扣-数据库-185-部门工资前三高的员工/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-185-部门工资前三高的员工/","excerpt":"","text":"Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。 |----|-------|--------|--------------| Id Name Salary DepartmentId 1 Joe 70000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 5 Janet 69000 1 6 Randy 85000 1 ---- ------- -------- -------------- Department 表包含公司所有部门的信息。 |----|----------| Id Name 1 IT 2 Sales ---- ---------- 编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回： |------------|----------|--------| Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 70000 Sales Henry 80000 Sales Sam 60000 ------------ ---------- -------- 12345--此处若有两个相同的薪水 只占一个前三的名额 需要使用dense_rank()over()函数select B.name Department ,A.name Employee ,A.Salary from (select Salary,Name,DepartmentId ,dense_rank()OVER(PARTITION BY DepartmentId ORDER BY Salary desc) num from Employee ) A join Department B on A.DepartmentId=B.IDwhere A.num&lt;=3","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-184-部门工资最高的员工","slug":"力扣-数据库-184-部门工资最高的员工","date":"2019-05-10T02:20:11.000Z","updated":"2019-05-10T05:07:16.387Z","comments":true,"path":"2019/05/10/力扣-数据库-184-部门工资最高的员工/","link":"","permalink":"https://jianlin1993.github.io/2019/05/10/力扣-数据库-184-部门工资最高的员工/","excerpt":"","text":"Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 |----|-------|--------|--------------| Id Name Salary DepartmentId 1 Joe 70000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 ---- ------- -------- -------------- Department 表包含公司所有部门的信息。 |----|----------| Id Name 1 IT 2 Sales ---- ---------- 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 |------------|----------|--------| Department Employee Salary IT Max 90000 Sales Henry 80000 ------------ ---------- -------- 12345--使用oracle分析函数rank()over()进行排序select B.name Department ,A.name Employee ,A.Salary from (select Salary,Name,DepartmentId ,rank()OVER(PARTITION BY DepartmentId ORDER BY Salary desc) num from Employee ) A join Department B on A.DepartmentId=B.IDwhere A.num=1","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-180-连续出现的数字","slug":"力扣-数据库-180-连续出现的数字","date":"2019-05-09T10:12:18.000Z","updated":"2019-05-10T05:07:16.319Z","comments":true,"path":"2019/05/09/力扣-数据库-180-连续出现的数字/","link":"","permalink":"https://jianlin1993.github.io/2019/05/09/力扣-数据库-180-连续出现的数字/","excerpt":"","text":"编写一个 SQL 查询，查找所有至少连续出现三次的数字。 |----|-----| Id Num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 ---- ----- 例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。 |-----------------| ConsecutiveNums 1 ----------------- 1234select distinct num ConsecutiveNums from(select lag(num,1,null)over(order by id) last_num,num,lead(num,1,null)over(order by id) next_num from Logs ) A where A.last_num=A.num and A.next_num=A.num","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-178-分数排名","slug":"力扣-数据库-178-分数排名","date":"2019-05-09T09:56:26.000Z","updated":"2019-05-10T05:07:16.399Z","comments":true,"path":"2019/05/09/力扣-数据库-178-分数排名/","link":"","permalink":"https://jianlin1993.github.io/2019/05/09/力扣-数据库-178-分数排名/","excerpt":"","text":"编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 |----|-------| Id Score 1 3.50 2 3.65 3 4.00 4 3.85 5 4.00 6 3.65 ---- ------- 例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： |-------|------| Score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 ------- ------ 1select Score,dense_rank() over(order by Score desc) rank from Scores;","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"力扣-数据库-177-第N高薪水","slug":"力扣-数据库-177-第N高薪水","date":"2019-05-09T09:40:34.000Z","updated":"2019-05-10T05:07:16.361Z","comments":true,"path":"2019/05/09/力扣-数据库-177-第N高薪水/","link":"","permalink":"https://jianlin1993.github.io/2019/05/09/力扣-数据库-177-第N高薪水/","excerpt":"","text":"编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 |----|--------| Id Salary 1 100 2 200 3 300 ---- -------- 例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。 |------------------------| getNthHighestSalary(2) 200 ------------------------ 12345678910111213141516171819--①CREATE FUNCTION getNthHighestSalary(N IN NUMBER) RETURN NUMBER ISresult NUMBER;BEGIN /* Write your PL/SQL query statement below */ select(SELECT SecondHighestSalary FROM ( select Salary SecondHighestSalary,ROWNUM num from(select distinct Salary from Employee order by Salary desc)) WHERE num=N) SecondHighestSalary into result from dual; RETURN result;END;--② 使用分析函数CREATE FUNCTION getNthHighestSalary(N IN NUMBER) RETURN NUMBER ISresult NUMBER;BEGIN select max(salary) into result from( select salary,dense_rank() over(order by salary desc) as rn from employee) where rn = n; RETURN result;END;","categories":[{"name":"LeetCode-DataBase","slug":"LeetCode-DataBase","permalink":"https://jianlin1993.github.io/categories/LeetCode-DataBase/"}],"tags":[]},{"title":"SpringBoot事务使用","slug":"SpringBoot事务使用","date":"2019-05-06T09:25:57.000Z","updated":"2019-05-07T07:35:13.954Z","comments":true,"path":"2019/05/06/SpringBoot事务使用/","link":"","permalink":"https://jianlin1993.github.io/2019/05/06/SpringBoot事务使用/","excerpt":"","text":"¶Springboot中使用事务的方式： 启动类加上@EnableTransactionManagement注解，开启事务支持（其实默认是开启的）。 在使用事务的public（只有public支持事务）方法（或者类-相当于该类的所有public方法都使用）加上@Transactional注解。 在实际使用中一般是在service(业务层)中使用@Transactional，那么对于controller-&gt;service流程中： 如果controller未开启事务，service中开始了事务，service成功执行，controller在之后的运行中出现异常（错误），不会自动回滚。 也就是说，只有在开启事务的方法中出现异常（默认只有非检测性异常才生效-RuntimeException ）（错误-Error）才会自动回滚。 如果想要对抛出的任何异常都进行自动回滚（而不是只针对RuntimeException），只需要在使用@Transactional(rollbackFor = Exception.class)即可。 ¶开启事务的方法中事务回滚的情况： 未发现的异常，程序运行过程中自动抛出RuntimeException或者其子类，程序终止，自动回滚。 使用TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();进行手动回滚。 注意：如果在try-catch语句中对可能出现的异常（RuntimeException）进行了处理，没有再手动throw异常，spring认为该方法成功执行， 不会进行回滚，此时需要进行手动回滚，另外，如果try-catch语句在finally中进行了return操作，那么catch中手动抛出的异常也会被覆盖，同样不会自动回滚。 12345678910111213141516//不会自动回滚try&#123; throw new RuntimeException();&#125;catch(RuntimeException e)&#123; e.printStackTrace();&#125;finally&#123;&#125;//会自动回滚try&#123; throw new RuntimeException();&#125;catch(RuntimeException e)&#123; e.printStackTrace(); throw new RuntimeException();&#125;finally&#123;&#125; ¶实际开发中一般是： 在controller层进行异常处理try-catch（因为controller的返回信息直接面向应用的使用人员,应该返回他们能读懂的信息),service层和dao层不进行异常处理，直接都向上抛出到controller中进行统一处理。","categories":[],"tags":[{"name":"springboot事务回滚","slug":"springboot事务回滚","permalink":"https://jianlin1993.github.io/tags/springboot事务回滚/"},{"name":"Transactional","slug":"Transactional","permalink":"https://jianlin1993.github.io/tags/Transactional/"}]}]}