{"meta":{"title":"葬瞳飘血的博客","subtitle":null,"description":"记录学习过程中遇到的问题","author":"葬瞳飘血","url":"https://jianlin1993.github.io","root":"/"},"pages":[{"title":"about","date":"2019-05-08T02:56:08.000Z","updated":"2019-05-08T02:56:08.252Z","comments":true,"path":"about/index.html","permalink":"https://jianlin1993.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-08T02:56:00.000Z","updated":"2019-05-08T02:56:00.814Z","comments":true,"path":"tags/index.html","permalink":"https://jianlin1993.github.io/tags/index.html","excerpt":"","text":""},{"title":"category","date":"2019-05-09T07:07:05.000Z","updated":"2019-05-09T07:07:05.543Z","comments":true,"path":"category/index.html","permalink":"https://jianlin1993.github.io/category/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣-数据库-177-第N高薪水","slug":"力扣-数据库-177-第N高薪水","date":"2019-05-09T09:40:34.000Z","updated":"2019-05-09T09:50:30.616Z","comments":true,"path":"2019/05/09/力扣-数据库-177-第N高薪水/","link":"","permalink":"https://jianlin1993.github.io/2019/05/09/力扣-数据库-177-第N高薪水/","excerpt":"","text":"编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 ±—±-------+ | Id | Salary | ±—±-------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | ±—±-------+ 例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。 ±-----------------------+ | getNthHighestSalary(2) | ±-----------------------+ | 200 | ±-----------------------+ 12345678910111213141516171819--①CREATE FUNCTION getNthHighestSalary(N IN NUMBER) RETURN NUMBER ISresult NUMBER;BEGIN /* Write your PL/SQL query statement below */ select(SELECT SecondHighestSalary FROM ( select Salary SecondHighestSalary,ROWNUM num from(select distinct Salary from Employee order by Salary desc)) WHERE num=N) SecondHighestSalary into result from dual; RETURN result;END;--② 使用分析函数CREATE FUNCTION getNthHighestSalary(N IN NUMBER) RETURN NUMBER ISresult NUMBER;BEGIN select max(salary) into result from( select salary,dense_rank() over(order by salary desc) as rn from employee) where rn = n; RETURN result;END;","categories":[],"tags":[]},{"title":"SpringBoot事务使用","slug":"SpringBoot事务使用","date":"2019-05-06T09:25:57.000Z","updated":"2019-05-07T07:35:13.954Z","comments":true,"path":"2019/05/06/SpringBoot事务使用/","link":"","permalink":"https://jianlin1993.github.io/2019/05/06/SpringBoot事务使用/","excerpt":"","text":"¶Springboot中使用事务的方式： 启动类加上@EnableTransactionManagement注解，开启事务支持（其实默认是开启的）。 在使用事务的public（只有public支持事务）方法（或者类-相当于该类的所有public方法都使用）加上@Transactional注解。 在实际使用中一般是在service(业务层)中使用@Transactional，那么对于controller-&gt;service流程中： 如果controller未开启事务，service中开始了事务，service成功执行，controller在之后的运行中出现异常（错误），不会自动回滚。 也就是说，只有在开启事务的方法中出现异常（默认只有非检测性异常才生效-RuntimeException ）（错误-Error）才会自动回滚。 如果想要对抛出的任何异常都进行自动回滚（而不是只针对RuntimeException），只需要在使用@Transactional(rollbackFor = Exception.class)即可。 ¶开启事务的方法中事务回滚的情况： 未发现的异常，程序运行过程中自动抛出RuntimeException或者其子类，程序终止，自动回滚。 使用TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();进行手动回滚。 注意：如果在try-catch语句中对可能出现的异常（RuntimeException）进行了处理，没有再手动throw异常，spring认为该方法成功执行， 不会进行回滚，此时需要进行手动回滚，另外，如果try-catch语句在finally中进行了return操作，那么catch中手动抛出的异常也会被覆盖，同样不会自动回滚。 12345678910111213141516//不会自动回滚try&#123; throw new RuntimeException();&#125;catch(RuntimeException e)&#123; e.printStackTrace();&#125;finally&#123;&#125;//会自动回滚try&#123; throw new RuntimeException();&#125;catch(RuntimeException e)&#123; e.printStackTrace(); throw new RuntimeException();&#125;finally&#123;&#125; ¶实际开发中一般是： 在controller层进行异常处理try-catch（因为controller的返回信息直接面向应用的使用人员,应该返回他们能读懂的信息),service层和dao层不进行异常处理，直接都向上抛出到controller中进行统一处理。","categories":[],"tags":[{"name":"springboot事务回滚","slug":"springboot事务回滚","permalink":"https://jianlin1993.github.io/tags/springboot事务回滚/"},{"name":"Transactional","slug":"Transactional","permalink":"https://jianlin1993.github.io/tags/Transactional/"}]}]}