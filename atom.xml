<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葬瞳飘血的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jianlin1993.github.io/"/>
  <updated>2019-05-09T09:50:30.616Z</updated>
  <id>https://jianlin1993.github.io/</id>
  
  <author>
    <name>葬瞳飘血</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣-数据库-177-第N高薪水</title>
    <link href="https://jianlin1993.github.io/2019/05/09/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-177-%E7%AC%ACN%E9%AB%98%E8%96%AA%E6%B0%B4/"/>
    <id>https://jianlin1993.github.io/2019/05/09/力扣-数据库-177-第N高薪水/</id>
    <published>2019-05-09T09:40:34.000Z</published>
    <updated>2019-05-09T09:50:30.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</p><p>±—±-------+<br>| Id | Salary |<br>±—±-------+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>±—±-------+<br>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</p><p>±-----------------------+<br>| getNthHighestSalary(2) |<br>±-----------------------+<br>| 200                    |<br>±-----------------------+</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--①</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="keyword">IN</span> <span class="built_in">NUMBER</span>) <span class="keyword">RETURN</span> <span class="built_in">NUMBER</span> <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">result</span> <span class="built_in">NUMBER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">/* Write your PL/SQL query statement below */</span></span><br><span class="line">    <span class="keyword">select</span>(</span><br><span class="line"><span class="keyword">SELECT</span> SecondHighestSalary <span class="keyword">FROM</span> ( <span class="keyword">select</span> Salary SecondHighestSalary,<span class="keyword">ROWNUM</span> <span class="keyword">num</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>)) <span class="keyword">WHERE</span> <span class="keyword">num</span>=N) SecondHighestSalary <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">    RETURN result;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">--② 使用分析函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="keyword">IN</span> <span class="built_in">NUMBER</span>) <span class="keyword">RETURN</span> <span class="built_in">NUMBER</span> <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">result</span> <span class="built_in">NUMBER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> salary,<span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> rn <span class="keyword">from</span> employee)</span><br><span class="line">    <span class="keyword">where</span> rn = n;</span><br><span class="line">    RETURN result;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。&lt;/p&gt;
&lt;p&gt;±—±-------+&lt;br&gt;
| Id | Salary |&lt;br&gt;
±—±-------+&lt;br&gt;
| 1  | 100    |&lt;br&gt;
|
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot事务使用</title>
    <link href="https://jianlin1993.github.io/2019/05/06/SpringBoot%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <id>https://jianlin1993.github.io/2019/05/06/SpringBoot事务使用/</id>
    <published>2019-05-06T09:25:57.000Z</published>
    <updated>2019-05-07T07:35:13.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springboot中使用事务的方式："><a class="header-anchor" href="#springboot中使用事务的方式：">¶</a>Springboot中使用事务的方式：</h2><ol><li><p>启动类加上<code>@EnableTransactionManagement</code>注解，开启事务支持（其实默认是开启的）。</p></li><li><p>在使用事务的<code>public</code>（只有public支持事务）方法（或者类-相当于该类的所有public方法都使用）加上<code>@Transactional</code>注解。</p></li><li><p>在实际使用中一般是在service(业务层)中使用<code>@Transactional</code>，那么对于controller-&gt;service流程中：</p><ul><li>如果controller未开启事务，service中开始了事务，service成功执行，controller在之后的运行中出现异常（错误），不会自动回滚。</li><li>也就是说，只有在开启事务的方法中出现异常（默认只有非检测性异常才生效-RuntimeException ）（错误-Error）才会自动回滚。</li><li>如果想要对抛出的任何异常都进行自动回滚（而不是只针对RuntimeException），只需要在使用<code>@Transactional(rollbackFor = Exception.class)</code>即可。</li></ul></li></ol><h2 id="开启事务的方法中事务回滚的情况："><a class="header-anchor" href="#开启事务的方法中事务回滚的情况：">¶</a>开启事务的方法中事务回滚的情况：</h2><ul><li>未发现的异常，程序运行过程中自动抛出RuntimeException或者其子类，程序终止，自动回滚。</li><li>使用<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</code>进行手动回滚。</li><li>注意：如果在try-catch语句中对可能出现的异常（RuntimeException）进行了处理，没有再手动throw异常，spring认为该方法成功执行，</li><li>不会进行回滚，此时需要进行手动回滚，另外，如果try-catch语句在finally中进行了return操作，那么catch中手动抛出的异常也会被覆盖，同样不会自动回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会自动回滚</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会自动回滚</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际开发中一般是："><a class="header-anchor" href="#实际开发中一般是：">¶</a>实际开发中一般是：</h2><p>在controller层进行异常处理try-catch（因为controller的返回信息直接面向应用的使用人员,应该返回他们能读懂的信息),service层和dao层不进行异常处理，直接都向上抛出到controller中进行统一处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;springboot中使用事务的方式：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#springboot中使用事务的方式：&quot;&gt;¶&lt;/a&gt;Springboot中使用事务的方式：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动类加上&lt;code&gt;@Ena
      
    
    </summary>
    
    
      <category term="springboot事务回滚" scheme="https://jianlin1993.github.io/tags/springboot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/"/>
    
      <category term="Transactional" scheme="https://jianlin1993.github.io/tags/Transactional/"/>
    
  </entry>
  
</feed>
