<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葬瞳飘血的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jianlin1993.github.io/"/>
  <updated>2019-05-10T06:09:52.804Z</updated>
  <id>https://jianlin1993.github.io/</id>
  
  <author>
    <name>葬瞳飘血</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣-数据库-627-交换工资</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-627-%E4%BA%A4%E6%8D%A2%E5%B7%A5%E8%B5%84/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-627-交换工资/</id>
    <published>2019-05-10T03:51:58.000Z</published>
    <updated>2019-05-10T06:09:52.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。<br>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。<br>例如：</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>m</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>f</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>m</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>f</td><td>500</td></tr></tbody></table><p>运行你所编写的更新语句之后，将会得到以下表:</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>f</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>m</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>f</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>m</td><td>500</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方法一：使用decode</span></span><br><span class="line"><span class="keyword">update</span> salary  <span class="keyword">set</span> sex=<span class="keyword">decode</span>(sex,<span class="string">'f'</span>,<span class="string">'m'</span>,<span class="string">'f'</span>);</span><br><span class="line"><span class="comment">--方法二：使用case when</span></span><br><span class="line"><span class="keyword">update</span> salary  <span class="keyword">set</span> sex=<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">'m'</span> <span class="keyword">then</span> <span class="string">'f'</span> <span class="keyword">else</span> <span class="string">'m'</span> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。&lt;br&gt;
注意，您必只能写一个 U
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-626-换座位</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-626-%E6%8D%A2%E5%BA%A7%E4%BD%8D/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-626-换座位/</id>
    <published>2019-05-10T03:51:46.000Z</published>
    <updated>2019-05-10T05:07:16.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。<br>其中纵列的 id 是连续递增的<br>小美想改变相邻俩学生的座位。<br>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？<br>示例：<br>|---------|---------|</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Abbot</td></tr><tr><td>2</td><td>Doris</td></tr><tr><td>3</td><td>Emerson</td></tr><tr><td>4</td><td>Green</td></tr><tr><td>5</td><td>Jeames</td></tr><tr><td>---------</td><td>---------</td></tr></tbody></table><p>假如数据输入的是上表，则输出结果如下：<br>|---------|---------|</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Doris</td></tr><tr><td>2</td><td>Abbot</td></tr><tr><td>3</td><td>Green</td></tr><tr><td>4</td><td>Emerson</td></tr><tr><td>5</td><td>Jeames</td></tr><tr><td>---------</td><td>---------</td></tr></tbody></table><p>注意：<br>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">CASE</span> </span><br><span class="line">            <span class="keyword">WHEN</span> <span class="keyword">MOD</span>(<span class="keyword">id</span>,<span class="number">2</span>) = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">id</span> = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> seat) <span class="keyword">THEN</span> <span class="keyword">id</span></span><br><span class="line">            <span class="keyword">WHEN</span> <span class="keyword">MOD</span>(<span class="keyword">id</span>,<span class="number">2</span>) = <span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">id</span>|<span class="number">1</span></span><br><span class="line">            <span class="keyword">ElSE</span> <span class="keyword">id</span><span class="number">-1</span></span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> <span class="keyword">id</span>, student</span><br><span class="line"><span class="keyword">FROM</span> seat</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">mod</span>(<span class="keyword">id</span>,<span class="number">2</span>)=<span class="number">1</span> <span class="keyword">and</span> next_student <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> next_student </span><br><span class="line"><span class="keyword">when</span>  <span class="keyword">mod</span>(<span class="keyword">id</span>,<span class="number">2</span>)=<span class="number">0</span> <span class="keyword">then</span> last_student</span><br><span class="line"><span class="keyword">else</span> student <span class="keyword">end</span> student </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>,lag(student,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) last_student,student,<span class="keyword">lead</span>(student,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) next_student</span><br><span class="line"><span class="keyword">from</span> seat )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。&lt;br&gt;
其中纵列的 id 是连续递增的&lt;br&gt;
小美想改变相邻俩学生的座位。&lt;br&gt;
你能不能帮她写一个 SQL query 来输出小美想要
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-620-有趣的电影</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-620-%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-620-有趣的电影/</id>
    <published>2019-05-10T03:51:35.000Z</published>
    <updated>2019-05-10T05:07:16.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p><p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。<br>例如，下表 cinema:<br>|---------|-----------|--------------|-----------|</p><table><thead><tr><th>id</th><th>movie</th><th>description</th><th>rating</th></tr></thead><tbody><tr><td>1</td><td>War</td><td>great 3D</td><td>8.9</td></tr><tr><td>2</td><td>Science</td><td>fiction</td><td>8.5</td></tr><tr><td>3</td><td>irish</td><td>boring</td><td>6.2</td></tr><tr><td>4</td><td>Ice song</td><td>Fantacy</td><td>8.6</td></tr><tr><td>5</td><td>House card</td><td>Interesting</td><td>9.1</td></tr><tr><td>---------</td><td>-----------</td><td>--------------</td><td>-----------</td></tr></tbody></table><p>对于上面的例子，则正确的输出是为：<br>|---------|-----------|--------------|-----------|</p><table><thead><tr><th>id</th><th>movie</th><th>description</th><th>rating</th></tr></thead><tbody><tr><td>5</td><td>House card</td><td>Interesting</td><td>9.1</td></tr><tr><td>1</td><td>War</td><td>great 3D</td><td>8.9</td></tr><tr><td>---------</td><td>-----------</td><td>--------------</td><td>-----------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,movie,description,rating  <span class="keyword">from</span> cinema</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">mod</span>(<span class="keyword">id</span>,<span class="number">2</span>)=<span class="number">1</span> <span class="keyword">and</span> description!=<span class="string">'boring'</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。&lt;/p&gt;
&lt;p&gt;作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-601-体育馆的人流量</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-601-%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-601-体育馆的人流量/</id>
    <published>2019-05-10T03:51:14.000Z</published>
    <updated>2019-05-13T06:49:58.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。<br>请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。<br>例如，表 stadium：<br>|------|------------|-----------|</p><table><thead><tr><th>id</th><th>date</th><th>people</th></tr></thead><tbody><tr><td>1</td><td>2017-01-01</td><td>10</td></tr><tr><td>2</td><td>2017-01-02</td><td>109</td></tr><tr><td>3</td><td>2017-01-03</td><td>150</td></tr><tr><td>4</td><td>2017-01-04</td><td>99</td></tr><tr><td>5</td><td>2017-01-05</td><td>145</td></tr><tr><td>6</td><td>2017-01-06</td><td>1455</td></tr><tr><td>7</td><td>2017-01-07</td><td>199</td></tr><tr><td>8</td><td>2017-01-08</td><td>188</td></tr><tr><td>------</td><td>------------</td><td>-----------</td></tr></tbody></table><p>对于上面的示例数据，输出为：<br>|------|------------|-----------|</p><table><thead><tr><th>id</th><th>date</th><th>people</th></tr></thead><tbody><tr><td>5</td><td>2017-01-05</td><td>145</td></tr><tr><td>6</td><td>2017-01-06</td><td>1455</td></tr><tr><td>7</td><td>2017-01-07</td><td>199</td></tr><tr><td>8</td><td>2017-01-08</td><td>188</td></tr><tr><td>------</td><td>------------</td><td>-----------</td></tr></tbody></table><p>Note:<br>每天只有一行记录，日期随着 id 的增加而增加。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方法一：</span></span><br><span class="line"><span class="keyword">SELECT</span> A.id, to_char(A.visit_date, <span class="string">'yyyy-MM-dd'</span>) <span class="keyword">AS</span> visit_date, A.people</span><br><span class="line"><span class="keyword">FROM</span> stadium A</span><br><span class="line"><span class="keyword">WHERE</span> A.people &gt;= <span class="number">100</span></span><br><span class="line">    <span class="keyword">AND</span> ((A.id - <span class="number">1</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> )</span><br><span class="line">            <span class="keyword">AND</span> A.id - <span class="number">2</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> ))</span><br><span class="line">        <span class="keyword">OR</span> (A.id - <span class="number">1</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> )</span><br><span class="line">            <span class="keyword">AND</span> A.id | <span class="number">1</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> ))</span><br><span class="line">        <span class="keyword">OR</span> (A.id | <span class="number">1</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> )</span><br><span class="line">            <span class="keyword">AND</span> A.id | <span class="number">2</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> stadium <span class="keyword">WHERE</span> people &gt;= <span class="number">100</span> ))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> A.id</span><br><span class="line"><span class="comment">--方法二：使用分析函数</span></span><br><span class="line"><span class="keyword">WITH</span> tmp <span class="keyword">AS</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">id</span>,last_id,next_id <span class="keyword">FROM</span> (</span><br><span class="line">      <span class="keyword">select</span> people,LAG(<span class="keyword">id</span>,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) last_id,<span class="keyword">id</span>,<span class="keyword">LEAD</span>(<span class="keyword">id</span>,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) next_id </span><br><span class="line">      <span class="keyword">from</span> stadium <span class="keyword">WHERE</span> people &gt;=<span class="number">100</span></span><br><span class="line">   ) A</span><br><span class="line">   <span class="keyword">WHERE</span> (A.id=A.last_id | <span class="number">1</span> <span class="keyword">AND</span> A.id=A.next_id - <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">SUBSTR</span>(visit_date,<span class="number">1</span>,<span class="number">10</span>) visit_date,people <span class="keyword">FROM</span> stadium </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="keyword">any</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span>  tmp</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> last_id <span class="keyword">FROM</span>  tmp</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> next_id <span class="keyword">FROM</span> tmp</span><br><span class="line">)<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。&lt;br&gt;
请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。&lt;br&gt;
例如，表 sta
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-596-超过5名学生的课</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-596-%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-596-超过5名学生的课/</id>
    <published>2019-05-10T03:50:53.000Z</published>
    <updated>2019-05-10T05:07:16.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一个courses 表 ，有: student (学生) 和 class (课程)。<br>请列出所有超过或等于5名学生的课。<br>例如,表:<br>|---------|------------|</p><table><thead><tr><th>student</th><th>class</th></tr></thead><tbody><tr><td>A</td><td>Math</td></tr><tr><td>B</td><td>English</td></tr><tr><td>C</td><td>Math</td></tr><tr><td>D</td><td>Biology</td></tr><tr><td>E</td><td>Math</td></tr><tr><td>F</td><td>Computer</td></tr><tr><td>G</td><td>Math</td></tr><tr><td>H</td><td>Math</td></tr><tr><td>I</td><td>Math</td></tr><tr><td>---------</td><td>------------</td></tr></tbody></table><p>应该输出:<br>|---------|</p><table><thead><tr><th>class</th></tr></thead><tbody><tr><td>Math</td></tr><tr><td>---------</td></tr></tbody></table><p>Note:<br>学生在每个课中不应被重复计算。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">class</span> <span class="keyword">from</span> </span><br><span class="line"> (<span class="keyword">select</span> <span class="keyword">distinct</span> student,<span class="keyword">class</span> <span class="keyword">from</span> courses)</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span> <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;=<span class="number">5</span></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">class</span> <span class="keyword">from</span> courses <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span> <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> student)&gt;=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有一个courses 表 ，有: student (学生) 和 class (课程)。&lt;br&gt;
请列出所有超过或等于5名学生的课。&lt;br&gt;
例如,表:&lt;br&gt;
|---------|------------|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-595-大的国家</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-595-%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-595-大的国家/</id>
    <published>2019-05-10T03:50:29.000Z</published>
    <updated>2019-05-10T05:07:16.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里有张 World 表<br>|-----------------|------------|------------|--------------|---------------|</p><table><thead><tr><th>name</th><th>continent</th><th>area</th><th>population</th><th>gdp</th></tr></thead><tbody><tr><td>Afghanistan</td><td>Asia</td><td>652230</td><td>25500100</td><td>20343000</td></tr><tr><td>Albania</td><td>Europe</td><td>28748</td><td>2831741</td><td>12960000</td></tr><tr><td>Algeria</td><td>Africa</td><td>2381741</td><td>37100000</td><td>188681000</td></tr><tr><td>Andorra</td><td>Europe</td><td>468</td><td>78115</td><td>3712000</td></tr><tr><td>Angola</td><td>Africa</td><td>1246700</td><td>20609294</td><td>100990000</td></tr><tr><td>-----------------</td><td>------------</td><td>------------</td><td>--------------</td><td>---------------</td></tr></tbody></table><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。<br>例如，根据上表，我们应该输出:<br>|--------------|-------------|--------------|</p><table><thead><tr><th>name</th><th>population</th><th>area</th></tr></thead><tbody><tr><td>Afghanistan</td><td>25500100</td><td>652230</td></tr><tr><td>Algeria</td><td>37100000</td><td>2381741</td></tr><tr><td>--------------</td><td>-------------</td><td>--------------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方法一：使用or</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,population,area <span class="keyword">from</span> World </span><br><span class="line"><span class="keyword">where</span>  area &gt;<span class="number">3000000</span> <span class="keyword">or</span> population &gt;<span class="number">25000000</span></span><br><span class="line"><span class="comment">--方法二：使用union代替or  效率更高</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,population,area <span class="keyword">from</span> World </span><br><span class="line"><span class="keyword">where</span>  area &gt;<span class="number">3000000</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,population,area <span class="keyword">from</span> World </span><br><span class="line"><span class="keyword">where</span>  population &gt;<span class="number">25000000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这里有张 World 表&lt;br&gt;
|-----------------|------------|------------|--------------|---------------|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-262-行程和用户</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-262-%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-262-行程和用户/</id>
    <published>2019-05-10T03:50:11.000Z</published>
    <updated>2019-05-10T07:50:01.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。</p><table><thead><tr><th>Id</th><th>Client_Id</th><th>Driver_Id</th><th>City_Id</th><th>Status</th><th>Request_at</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>10</td><td>1</td><td>completed</td><td>2013-10-01</td></tr><tr><td>2</td><td>2</td><td>11</td><td>1</td><td>cancelled_by_driver</td><td>2013-10-01</td></tr><tr><td>3</td><td>3</td><td>12</td><td>6</td><td>completed</td><td>2013-10-01</td></tr><tr><td>4</td><td>4</td><td>13</td><td>6</td><td>cancelled_by_client</td><td>2013-10-01</td></tr><tr><td>5</td><td>1</td><td>10</td><td>1</td><td>completed</td><td>2013-10-02</td></tr><tr><td>6</td><td>2</td><td>11</td><td>6</td><td>completed</td><td>2013-10-02</td></tr><tr><td>7</td><td>3</td><td>12</td><td>6</td><td>completed</td><td>2013-10-02</td></tr><tr><td>8</td><td>2</td><td>12</td><td>12</td><td>completed</td><td>2013-10-03</td></tr><tr><td>9</td><td>3</td><td>10</td><td>12</td><td>completed</td><td>2013-10-03</td></tr><tr><td>10</td><td>4</td><td>13</td><td>12</td><td>cancelled_by_driver</td><td>2013-10-03</td></tr></tbody></table><p>Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。</p><table><thead><tr><th>Users_Id</th><th>Banned</th><th>Role</th></tr></thead><tbody><tr><td>1</td><td>No</td><td>client</td></tr><tr><td>2</td><td>Yes</td><td>client</td></tr><tr><td>3</td><td>No</td><td>client</td></tr><tr><td>4</td><td>No</td><td>client</td></tr><tr><td>10</td><td>No</td><td>driver</td></tr><tr><td>11</td><td>No</td><td>driver</td></tr><tr><td>12</td><td>No</td><td>driver</td></tr><tr><td>13</td><td>No</td><td>driver</td></tr></tbody></table><p>写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。<br>|------------|-------------------|</p><table><thead><tr><th>Day</th><th>Cancellation Rate</th></tr></thead><tbody><tr><td>2013-10-01</td><td>0.33</td></tr><tr><td>2013-10-02</td><td>0.00</td></tr><tr><td>2013-10-03</td><td>0.50</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 非禁止用户取消率=非禁止用户行程取消总数(包括司机取消的)/非禁止用户行程总数</span></span><br><span class="line">方法一：</span><br><span class="line"><span class="keyword">select</span> Request_at <span class="keyword">day</span>,<span class="keyword">round</span>(nvl(<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">Status</span> = <span class="string">'completed'</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>),<span class="number">0</span>)/<span class="keyword">count</span>(<span class="number">1</span>),<span class="number">2</span>)  <span class="string">"Cancellation Rate"</span> </span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span>  A.status, A.request_at <span class="keyword">from</span> Trips A</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">users</span> B <span class="keyword">on</span> A.client_id = B.users_id</span><br><span class="line"><span class="keyword">where</span> B.banned = <span class="string">'No'</span> <span class="keyword">and</span> A.request_at <span class="keyword">between</span> <span class="string">'2013-10-01'</span> <span class="keyword">and</span> <span class="string">'2013-10-03'</span>) <span class="keyword">group</span> <span class="keyword">by</span> Request_at</span><br><span class="line"><span class="comment">--方法二：</span></span><br><span class="line"><span class="keyword">select</span> B.day,<span class="keyword">round</span>(nvl(A.num,<span class="number">0</span>)/B.num,<span class="number">2</span>) <span class="string">"Cancellation Rate"</span> <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> nvl(<span class="keyword">count</span>(*),<span class="number">0</span>) <span class="keyword">num</span>,Request_at <span class="keyword">Day</span> <span class="keyword">from</span> Trips A </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">users</span> B <span class="keyword">on</span> A.Client_Id=B.Users_Id</span><br><span class="line"><span class="comment">--join users C on A.Client_Id=C.Users_Id</span></span><br><span class="line"><span class="keyword">where</span> B.Banned=<span class="string">'No'</span> <span class="keyword">and</span> A.Status=<span class="keyword">any</span>(<span class="string">'cancelled_by_driver'</span>,<span class="string">'cancelled_by_client'</span>)</span><br><span class="line"> <span class="keyword">and</span> A.Request_at <span class="keyword">between</span> <span class="string">'2013-10-01'</span> <span class="keyword">and</span> <span class="string">'2013-10-03'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Request_at) A</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span>  <span class="comment">--使用外连接  防止丢失数据</span></span><br><span class="line">(<span class="keyword">select</span> nvl(<span class="keyword">count</span>(*),<span class="number">1</span>) <span class="keyword">num</span>,Request_at <span class="keyword">Day</span> <span class="keyword">from</span> Trips A </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">users</span> B <span class="keyword">on</span> A.Client_Id=B.Users_Id</span><br><span class="line"><span class="comment">--join users C on A.Client_Id=C.Users_Id</span></span><br><span class="line"><span class="keyword">where</span> B.Banned=<span class="string">'No'</span>  <span class="keyword">and</span> A.Request_at <span class="keyword">between</span> <span class="string">'2013-10-01'</span> <span class="keyword">and</span> <span class="string">'2013-10-03'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Request_at) B <span class="keyword">on</span> A.Day=B.Day <span class="keyword">order</span> <span class="keyword">by</span> B.day</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-197-上升的温度</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-197-%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-197-上升的温度/</id>
    <published>2019-05-10T03:15:58.000Z</published>
    <updated>2019-05-13T06:46:55.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。<br>|---------|------------------|------------------|</p><table><thead><tr><th>Id(INT)</th><th>RecordDate(DATE)</th><th>Temperature(INT)</th></tr></thead><tbody><tr><td>1</td><td>2015-01-01</td><td>10</td></tr><tr><td>2</td><td>2015-01-02</td><td>25</td></tr><tr><td>3</td><td>2015-01-03</td><td>20</td></tr><tr><td>4</td><td>2015-01-04</td><td>30</td></tr><tr><td>---------</td><td>------------------</td><td>------------------</td></tr></tbody></table><p>例如，根据上述给定的 Weather 表格，返回如下 Id:</p><p>|----|</p><table><thead><tr><th>Id</th></tr></thead><tbody><tr><td>2</td></tr><tr><td>4</td></tr><tr><td>----</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方法一：直接使用表自身连接</span></span><br><span class="line"><span class="keyword">select</span> A.Id</span><br><span class="line"><span class="keyword">from</span> Weather A <span class="keyword">join</span> Weather B</span><br><span class="line"><span class="keyword">on</span> A.RecordDate = B.RecordDate</span><br><span class="line"><span class="keyword">where</span> A.Temperature &gt; B.Temperature </span><br><span class="line"></span><br><span class="line"><span class="comment">--方法二：使用偏移分析函数  根据日期（Date类型）排序（id和日期可能不是对应的）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>,Temperature,lag(Temperature,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> RecordDate) last_Temperature,</span><br><span class="line"> RecordDate,lag(RecordDate,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> RecordDate) last_RecordDate</span><br><span class="line"><span class="keyword">from</span> Weather) A <span class="keyword">where</span> A.Temperature&gt;A.last_Temperature <span class="keyword">and</span> A.last_RecordDate=A.RecordDate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。&lt;br&gt;
|---------|------------------|------------------|&lt;/p&gt;
&lt;table&gt;
&lt;
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-185-部门工资前三高的员工</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-185-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-185-部门工资前三高的员工/</id>
    <published>2019-05-10T03:01:38.000Z</published>
    <updated>2019-05-10T05:07:16.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。<br>|----|-------|--------|--------------|</p><table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>DepartmentId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td></tr><tr><td>5</td><td>Janet</td><td>69000</td><td>1</td></tr><tr><td>6</td><td>Randy</td><td>85000</td><td>1</td></tr><tr><td>----</td><td>-------</td><td>--------</td><td>--------------</td></tr></tbody></table><p>Department 表包含公司所有部门的信息。</p><p>|----|----------|</p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>IT</td></tr><tr><td>2</td><td>Sales</td></tr><tr><td>----</td><td>----------</td></tr></tbody></table><p>编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：</p><p>|------------|----------|--------|</p><table><thead><tr><th>Department</th><th>Employee</th><th>Salary</th></tr></thead><tbody><tr><td>IT</td><td>Max</td><td>90000</td></tr><tr><td>IT</td><td>Randy</td><td>85000</td></tr><tr><td>IT</td><td>Joe</td><td>70000</td></tr><tr><td>Sales</td><td>Henry</td><td>80000</td></tr><tr><td>Sales</td><td>Sam</td><td>60000</td></tr><tr><td>------------</td><td>----------</td><td>--------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--此处若有两个相同的薪水  只占一个前三的名额  需要使用dense_rank()over()函数</span></span><br><span class="line"><span class="keyword">select</span> B.name Department ,A.name Employee ,A.Salary  <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> Salary,<span class="keyword">Name</span>,DepartmentId ,<span class="keyword">dense_rank</span>()<span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DepartmentId <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">desc</span>) <span class="keyword">num</span>   <span class="keyword">from</span> Employee ) A </span><br><span class="line"><span class="keyword">join</span> Department B <span class="keyword">on</span> A.DepartmentId=B.ID</span><br><span class="line"><span class="keyword">where</span> A.num&lt;=<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。&lt;br&gt;
|----|-------|--------|--------------|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-184-部门工资最高的员工</title>
    <link href="https://jianlin1993.github.io/2019/05/10/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://jianlin1993.github.io/2019/05/10/力扣-数据库-184-部门工资最高的员工/</id>
    <published>2019-05-10T02:20:11.000Z</published>
    <updated>2019-05-10T05:07:16.387Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。<br>|----|-------|--------|--------------|</p><table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>DepartmentId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td></tr><tr><td>----</td><td>-------</td><td>--------</td><td>--------------</td></tr></tbody></table><p>Department 表包含公司所有部门的信息。<br>|----|----------|</p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>IT</td></tr><tr><td>2</td><td>Sales</td></tr><tr><td>----</td><td>----------</td></tr></tbody></table><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。<br>|------------|----------|--------|</p><table><thead><tr><th>Department</th><th>Employee</th><th>Salary</th></tr></thead><tbody><tr><td>IT</td><td>Max</td><td>90000</td></tr><tr><td>Sales</td><td>Henry</td><td>80000</td></tr><tr><td>------------</td><td>----------</td><td>--------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用oracle分析函数rank()over()进行排序</span></span><br><span class="line"><span class="keyword">select</span> B.name Department ,A.name Employee ,A.Salary <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> Salary,<span class="keyword">Name</span>,DepartmentId ,<span class="keyword">rank</span>()<span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DepartmentId <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">desc</span>) <span class="keyword">num</span>  <span class="keyword">from</span> Employee ) A </span><br><span class="line"><span class="keyword">join</span> Department B <span class="keyword">on</span> A.DepartmentId=B.ID</span><br><span class="line"><span class="keyword">where</span> A.num=<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。&lt;br&gt;
|----|-------|--------|--------------|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-180-连续出现的数字</title>
    <link href="https://jianlin1993.github.io/2019/05/09/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-180-%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://jianlin1993.github.io/2019/05/09/力扣-数据库-180-连续出现的数字/</id>
    <published>2019-05-09T10:12:18.000Z</published>
    <updated>2019-05-10T05:07:16.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。<br>|----|-----|</p><table><thead><tr><th>Id</th><th>Num</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>2</td></tr><tr><td>5</td><td>1</td></tr><tr><td>6</td><td>2</td></tr><tr><td>7</td><td>2</td></tr><tr><td>----</td><td>-----</td></tr></tbody></table><p>例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。<br>|-----------------|</p><table><thead><tr><th>ConsecutiveNums</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>-----------------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">num</span> ConsecutiveNums  <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> lag(<span class="keyword">num</span>,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) last_num,<span class="keyword">num</span>,<span class="keyword">lead</span>(<span class="keyword">num</span>,<span class="number">1</span>,<span class="literal">null</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) next_num </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Logs</span> ) A </span><br><span class="line"><span class="keyword">where</span> A.last_num=A.num <span class="keyword">and</span>  A.next_num=A.num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询，查找所有至少连续出现三次的数字。&lt;br&gt;
|----|-----|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Id&lt;/th&gt;
&lt;th&gt;Num&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;

      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-178-分数排名</title>
    <link href="https://jianlin1993.github.io/2019/05/09/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-178-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/"/>
    <id>https://jianlin1993.github.io/2019/05/09/力扣-数据库-178-分数排名/</id>
    <published>2019-05-09T09:56:26.000Z</published>
    <updated>2019-05-10T05:07:16.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。<br>|----|-------|</p><table><thead><tr><th>Id</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>3.50</td></tr><tr><td>2</td><td>3.65</td></tr><tr><td>3</td><td>4.00</td></tr><tr><td>4</td><td>3.85</td></tr><tr><td>5</td><td>4.00</td></tr><tr><td>6</td><td>3.65</td></tr><tr><td>----</td><td>-------</td></tr></tbody></table><p>例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：<br>|-------|------|</p><table><thead><tr><th>Score</th><th>Rank</th></tr></thead><tbody><tr><td>4.00</td><td>1</td></tr><tr><td>4.00</td><td>1</td></tr><tr><td>3.85</td><td>2</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.50</td><td>4</td></tr><tr><td>-------</td><td>------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Score,<span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">rank</span> <span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。&lt;br&gt;
|----|-------|&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣-数据库-177-第N高薪水</title>
    <link href="https://jianlin1993.github.io/2019/05/09/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%93-177-%E7%AC%ACN%E9%AB%98%E8%96%AA%E6%B0%B4/"/>
    <id>https://jianlin1993.github.io/2019/05/09/力扣-数据库-177-第N高薪水/</id>
    <published>2019-05-09T09:40:34.000Z</published>
    <updated>2019-05-10T05:07:16.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</p><p>|----|--------|</p><table><thead><tr><th>Id</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr><tr><td>----</td><td>--------</td></tr></tbody></table><p>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</p><p>|------------------------|</p><table><thead><tr><th>getNthHighestSalary(2)</th></tr></thead><tbody><tr><td>200</td></tr><tr><td>------------------------</td></tr></tbody></table></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--①</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="keyword">IN</span> <span class="built_in">NUMBER</span>) <span class="keyword">RETURN</span> <span class="built_in">NUMBER</span> <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">result</span> <span class="built_in">NUMBER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">/* Write your PL/SQL query statement below */</span></span><br><span class="line">    <span class="keyword">select</span>(</span><br><span class="line"><span class="keyword">SELECT</span> SecondHighestSalary <span class="keyword">FROM</span> ( <span class="keyword">select</span> Salary SecondHighestSalary,<span class="keyword">ROWNUM</span> <span class="keyword">num</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>)) <span class="keyword">WHERE</span> <span class="keyword">num</span>=N) SecondHighestSalary <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">    RETURN result;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">--② 使用分析函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="keyword">IN</span> <span class="built_in">NUMBER</span>) <span class="keyword">RETURN</span> <span class="built_in">NUMBER</span> <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">result</span> <span class="built_in">NUMBER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> salary,<span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> rn <span class="keyword">from</span> employee)</span><br><span class="line">    <span class="keyword">where</span> rn = n;</span><br><span class="line">    RETURN result;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。&lt;/p&gt;
&lt;p&gt;|----|--------|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Id&lt;/th&gt;
&lt;th&gt;Salary&lt;/th&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="LeetCode-DataBase" scheme="https://jianlin1993.github.io/categories/LeetCode-DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot事务使用</title>
    <link href="https://jianlin1993.github.io/2019/05/06/SpringBoot%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <id>https://jianlin1993.github.io/2019/05/06/SpringBoot事务使用/</id>
    <published>2019-05-06T09:25:57.000Z</published>
    <updated>2019-05-07T07:35:13.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springboot中使用事务的方式："><a class="header-anchor" href="#springboot中使用事务的方式：">¶</a>Springboot中使用事务的方式：</h2><ol><li><p>启动类加上<code>@EnableTransactionManagement</code>注解，开启事务支持（其实默认是开启的）。</p></li><li><p>在使用事务的<code>public</code>（只有public支持事务）方法（或者类-相当于该类的所有public方法都使用）加上<code>@Transactional</code>注解。</p></li><li><p>在实际使用中一般是在service(业务层)中使用<code>@Transactional</code>，那么对于controller-&gt;service流程中：</p><ul><li>如果controller未开启事务，service中开始了事务，service成功执行，controller在之后的运行中出现异常（错误），不会自动回滚。</li><li>也就是说，只有在开启事务的方法中出现异常（默认只有非检测性异常才生效-RuntimeException ）（错误-Error）才会自动回滚。</li><li>如果想要对抛出的任何异常都进行自动回滚（而不是只针对RuntimeException），只需要在使用<code>@Transactional(rollbackFor = Exception.class)</code>即可。</li></ul></li></ol><h2 id="开启事务的方法中事务回滚的情况："><a class="header-anchor" href="#开启事务的方法中事务回滚的情况：">¶</a>开启事务的方法中事务回滚的情况：</h2><ul><li>未发现的异常，程序运行过程中自动抛出RuntimeException或者其子类，程序终止，自动回滚。</li><li>使用<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</code>进行手动回滚。</li><li>注意：如果在try-catch语句中对可能出现的异常（RuntimeException）进行了处理，没有再手动throw异常，spring认为该方法成功执行，</li><li>不会进行回滚，此时需要进行手动回滚，另外，如果try-catch语句在finally中进行了return操作，那么catch中手动抛出的异常也会被覆盖，同样不会自动回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会自动回滚</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会自动回滚</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际开发中一般是："><a class="header-anchor" href="#实际开发中一般是：">¶</a>实际开发中一般是：</h2><p>在controller层进行异常处理try-catch（因为controller的返回信息直接面向应用的使用人员,应该返回他们能读懂的信息),service层和dao层不进行异常处理，直接都向上抛出到controller中进行统一处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;springboot中使用事务的方式：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#springboot中使用事务的方式：&quot;&gt;¶&lt;/a&gt;Springboot中使用事务的方式：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动类加上&lt;code&gt;@Ena
      
    
    </summary>
    
    
      <category term="springboot事务回滚" scheme="https://jianlin1993.github.io/tags/springboot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/"/>
    
      <category term="Transactional" scheme="https://jianlin1993.github.io/tags/Transactional/"/>
    
  </entry>
  
</feed>
